<?php

function uib_sebra__sync_places($limit) {
  $places = uib_sebra__sws_get('places?status=aktiv');

  foreach ($places->place as $place) {
    $place_id = (string)$place->code;
    $nid = uib_sebra__uib_ou_nid($place_id);
    if ($nid === NULL) {
      $node = uib_sebra__create_uib_ou($place_id);
      uibx_log("Created node $node->nid for place $place_id $place->name");
      if ($limit) {
        if (--$limit == 0)
          break;
      }
    }
  }
}

function uib_sebra__sws_url($path) {
  $url = variable_get('uib_sws_url', 'http://sebra.uib.no/sws/');
  $url .= $path;
  return $url;
}

function uib_sebra__sws_get($path) {
  $url = uib_sebra__sws_url($path);
  uibx_log('GET ' . $url);
  $contents = file_get_contents($url);
  if (preg_match("/^\s*No data(?:\n|$)/i", $contents))
    return NULL;
  $object = simplexml_load_string($contents);
  return $object;
}

/**
 * Look up the node id of the organisation unit with the given $place_id.
 */
function uib_sebra__uib_ou_nid($place_id) {
    $query = new EntityFieldQuery;
    $result = $query
      ->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', 'uib_ou')
      ->fieldCondition('field_uib_ou_id', 'value', $place_id, '=')
      ->range(0, 1)
      ->execute();

    if (!empty($result['node'])) {
      $nids = array_keys($result['node']);
      return $nids[0];
    }
    return NULL;
}

/**
 * Create a new node representing the organisation unit with the given
 * $place_id.
 *
 * Note that this function will create duplicates if called again for a
 * place that's already in the Drupal database.
 */
function uib_sebra__create_uib_ou($place_id) {
  $place = new SebraPlace($place_id);
  $node = new stdClass();
  $node->type = 'uib_ou';
  $node->title = $place->name;
  $node->uid = 1;
  $node->status = 1;
  $node->revision = 0;
  $node->language = 'und';
  $node->field_uib_ou_id['und'][0]['value'] = $place_id;
  $node->field_uib_ou_shortname['und'][0]['value'] = $place->alias;
  $node->field_uib_mail_domain['und'][0]['value'] = $place->maildomain;

  $node->field_uib_postal_address['und'][0]['thoroughfare'] = 'Postboks ' . $place->postbox;
  $node->field_uib_postal_address['und'][0]['postal_code'] = $place->postcode;
  $node->field_uib_postal_address['und'][0]['locality'] = $place->postarea;
  $node->field_uib_postal_address['und'][0]['country'] = 'NO';

  $node->field_uib_visit_address['und'][0]['thoroughfare'] = $place->address;
  $node->field_uib_visit_address['und'][0]['postal_code'] = $place->postcode;
  $node->field_uib_visit_address['und'][0]['locality'] = $place->postarea;
  $node->field_uib_visit_address['und'][0]['country'] = 'NO';

  if (isset($place->phone))
    $node->field_uib_phone['und'][0]['value'] = '+47 ' . $place->phone;
  if (isset($place->fax))
    $node->field_uib_fax['und'][0]['value'] = '+47 ' . $place->fax;

  node_save($node);
  return $node;
}

/**
 * Sync the 'field_uib_staff' of all areas that define a 'field_uib_sebra_id'.
 */
function uib_sebra__sync_areas() {
  // fetch all roles for all areas
  $all_area_roles = uib_sebra__sws_get('omraaderoller');

  $query = new EntityFieldQuery;
  $query = $query
    ->entityCondition('entity_type', 'node')
    ->propertyCondition('type', 'area')
    ->fieldOrderBy('field_uib_sebra_id', 'value')
    ;
  $result = $query->execute();

  $staff_unchanged = 0;
  $content_manager_unchanged = 0;
  $seen_sebra_id = array();
  foreach (array_keys($result['node']) as $nid) {
    $edit_p = FALSE;
    $area = node_load($nid);

    $sebra_id = $area->field_uib_sebra_id['und'][0]['value'];
    if (isset($seen_sebra_id[$sebra_id])) {
      // we can skip this one since all the fields we update are shared
      // between the translations.
      continue;
    }
    $seen_sebra_id[$sebra_id] = 1;
    $area_doc = uib_sebra__sws_get("omraader?omraadekode=$sebra_id");
    if (empty($area_doc)) {
      uibx_log("Can't get $sebra_id", 'error');
    }
    uib_sebra__sync_jobbnorge_id($area, $area_doc);
    $staff = array();
    if (isset($area_doc->omraade)) {
      foreach ($area_doc->omraade->visninger->uibid as $uname) {
        $account = user_load_by_name($uname);
        if (!$account) {
          $account = uib_sebra__sync_user($uname, FALSE, "area $sebra_id staff");
          if (!$account) {
            continue;
          }
        }
        $staff['und'][]['target_id'] = $account->uid;
      }
    }
    else {
      uibx_log("Sebra area $sebra_id empty", 'warning');
    }
    if (!isset($area->field_uib_staff) || $area->field_uib_staff != $staff) {
      $area->field_uib_staff = $staff;
      $edit_p = TRUE;
      uibx_log("Updating staff setting area /node/$nid");
    }
    else {
      $staff_unchanged++;
    }

    $content_manager = array();
    $area_roles = uib_sebra__get_area_roles($all_area_roles, $sebra_id);
    foreach ($area_roles as $uname) {
      $account = user_load_by_name($uname);
      if (!$account) {
        $account = uib_sebra__sync_user($uname, FALSE, "area $sebra_id roles");
        if (!$account) {
          continue;
        }
      }
      $content_manager['und'][]['target_id'] = $account->uid;
    }
    if (!isset($area->field_uib_content_manager) || $area->field_uib_content_manager != $content_manager) {
      $area->field_uib_content_manager = $content_manager;
      $edit_p = TRUE;
      uibx_log("Updating content_manager setting area /node/$nid");
    }
    else {
      $content_manager_unchanged++;
    }

    if ($edit_p)
      node_save($area);
  }
  uibx_log("staff attribute unchanged for $staff_unchanged areas");
  uibx_log("content_manager attribute unchanged for $content_manager_unchanged areas");
}

/**
 * Get area roles with the given sebra_id
 *
 * Returns array with usernames with roles: "Redaktør" or "Innholdsprodusent"
 * for a given area (sebra_id)
 */
function uib_sebra__get_area_roles($all_area_roles, $sebra_id) {
  $result = array();
  if (!empty($all_area_roles->administrator)) {

    foreach ($all_area_roles->administrator as $admin) {
      $username = (string)$admin['id'];

      foreach ($admin->role as $role) {
        $role_group = (string)$role['group'];

        foreach ($role->omraade_kode as $area_code) {
          if ((string)$area_code != $sebra_id)
            continue;

          if ($role_group == 'Redaktør' || $role_group == 'Innholdsprodusent') {
            array_push($result, $username);
          }
        }
      }
    }
  }
  return $result;
}

/**
 * Sync jobbnorge_id from område in Sebra to ou in w3.
 *
 */
function uib_sebra__sync_jobbnorge_id($area, $area_doc) {
  $jobbnorge_id = (string)$area_doc->omraade->JOBBNORGE_DEPID;
  if (!$jobbnorge_id)
    return;
  $place_id = (string)$area_doc->omraade->EIER_STED_KODE;
  //uibx_log("jobbnorge $place_id => $jobbnorge_id");
  if (isset($area->field_uib_ou['und'])) {
    $nid = $area->field_uib_ou['und'][0]['target_id'];
    $place = node_load($nid);
    if ($place->field_uib_ou_id['und'][0]['value'] != $place_id) {
      uibx_log("Mismatch for place code for /node/$nid $place_id", 'error');
      return;
    }
    if ( !is_numeric($jobbnorge_id) ) {
      uibx_log("jobbnorge_id not numeric for place code for /node/$nid", 'error');
      return;
    }
    if ($place->field_uib_jobbnorge_id['und'][0]['value'] != $jobbnorge_id) {
      $place->field_uib_jobbnorge_id['und'][0]['value'] = $jobbnorge_id;
      node_save($place);
      uibx_log("Updated jobbnorge_id for /node/$nid");
    }
  }
  else {
    uibx_log("No place set up for /node/$area->nid");
  }
}

/**
 * Sync users between Sebra and the Drual database.
 *
 * If $limit is provided only sync the given number of users.  In this case the
 * function maintains an internal counter in the variable
 * "uib_sebra_user_offset" and will start syncing from that user.
 *
 * Syncing with a $limit of 0 means unlimited and will take a long time.
 */

function uib_sebra__sync_users($limit, $do_block=FALSE) {
  $users = array_merge(
    uib_sebra__get_persons('staff'),
    uib_sebra__get_persons('extern')
  );
  //$users = array('adbho', 'gaa041', 'sbj051'); // debug with a smaller set
  $users_count = count($users);
  $offset = 0;

  if ($limit) {
    $offset = variable_get('uib_sebra_user_offset', 0);
    if ($offset >= $users_count)
      $offset = 0;
    variable_set('uib_sebra_user_offset', $offset + $limit);
    uibx_log("Starting to process $limit of $users_count users at offset $offset");
  }
  else {
    uibx_log("Processing $users_count users");
  }

  foreach ($users as $username) {
    if (--$offset > 0)
      continue;
    uib_sebra__sync_user($username, FALSE, 'persons staff+extern');
    if ($limit) {
      if (--$limit == 0)
        break;
    }
  }

  // look for users to block
  $users = array_flip($users); // make it easy to look them up by username

  $query = new EntityFieldQuery;
  $query = $query
    ->entityCondition('entity_type', 'user')
    ->fieldCondition('field_uib_user_domain', 'value', 'uib', '=');
  $result = $query->execute();
  $active_count = 0;
  $blocked_count = 0;
  foreach (array_keys($result['user']) as $uid) {
    $account = user_load($uid);
    if (isset($users[$account->name])) {
      if ($account->status == 0) {
        user_save($account, array(
          'status' => 1, // ACTIVE
        ));
        uibx_log("$account->name unblocked");
      }
      else {
        $active_count++;
      }
    }
    elseif ($account->status != 0) {
      if ($do_block) {
        user_save($account, array(
          'status' => 0, // BLOCKED
        ));
        uibx_log("$account->name blocked");
        $blocked_count++;
      }
      else {
        uibx_log("$account->name would be blocked");
      }
    }
    else {
      $blocked_count++;
    }
  }
  uibx_log("$active_count active and $blocked_count blocked uib-accounts");
}

/**
 * Returns the list of active usernames.  The $type argument limits the kind of users
 * to return.  It can be one of 'staff', 'student', or 'extern'.
 */

function uib_sebra__get_persons($type) {
  $persons_url = 'persons';
  if ($type)
    $persons_url .= "?type=$type";
  $persons = uib_sebra__sws_get($persons_url);
  $uids = array();
  foreach ($persons->person as $p) {
    $uids[] = (string)$p->id;
  }
  return $uids;
}

/**
 * Add uid to content_manager on areas
 *
 * Returns true if adding to content_manager, else false
 */
function uib_sebra__add_content_manager($content_manager_areas, $uid) {

  $res = FALSE;
  foreach ($content_manager_areas as $sebra_id) {
    $query = new EntityFieldQuery;
    $query = $query
      ->entityCondition('entity_type', 'node')
      ->propertyCondition('type', 'area')
      ->fieldCondition('field_uib_sebra_id', 'value', $sebra_id, '=');
    $result = $query->execute();

    if (isset($result['node'])) {
      foreach (array_keys($result['node']) as $nid) {

        $area = node_load($nid);
        $needle = array('target_id' => $uid);
        if ( !isset($area->field_uib_content_manager['und']) ||
          !in_array($needle, $area->field_uib_content_manager['und']) ) {

          $area->field_uib_content_manager['und'][]['target_id'] = $uid;
          node_save($area);
          $res = TRUE;
        }
      }
    }
  }
  return $res;
}

/**
 * Syncronice the given user with Sebra.  If the user did not already exist in
 * the Drupal database it will be created.  If it exist, this function will
 * figure out if any attributes need to be changed and if so update the user.
 *
 * The function logs what it does with uibx_log().
 *
 * The function returns the user object created/loaded.
 */

function uib_sebra__sync_user($username, $dry_run=FALSE, $ref=NULL) {
  $account = user_load_by_name($username);
  try {
    $u = new SebraPerson($username, $ref);
  }
  catch (Exception $e) {
    uibx_log($e->getMessage(), 'warning');
    if ($e->getCode() == 404)
      // Should we block the user before we return it then?
      return $account;
    throw $e;
  }

  $phones = array();
  if (!empty($u->phone_office))
    $phones['und'][]['value'] = '+47 ' . $u->phone_office;
  if (!empty($u->phone_mobile))
    $phones['und'][]['value'] = '+47 ' . $u->phone_mobile;

  if ($account) {
    $edit = array();
    if ($account->mail != $u->email)
      $edit['mail'] = $u->email;
    if ($account->status != 1) {
      $edit['status'] = 1;
      uibx_log("$account->name unblocked");
    }
    if ($account->field_uib_first_name['und'][0]['value'] != $u->first_name)
      $edit['field_uib_first_name']['und'][0]['value'] = $u->first_name;
    if ($account->field_uib_last_name['und'][0]['value'] != $u->last_name) {
      $edit['field_uib_last_name']['und'][0]['value'] = $u->last_name;
      $edit['field_uib_sort_name']['und'][0]['value'] = _uib_sebra__sort_name($u->last_name);
    }
    if ($account->field_uib_position['nb'][0]['value'] != $u->position_name_no)
      $edit['field_uib_position']['nb'][0]['value'] = $u->position_name_no;
    if ($account->field_uib_position['en'][0]['value'] != $u->position_name_en)
      $edit['field_uib_position']['en'][0]['value'] = $u->position_name_en;
    if ($account->field_uib_position_code['und'][0]['value'] != $u->position_code)
      $edit['field_uib_position_code']['und'][0]['value'] = $u->position_code;
    if ($account->field_uib_position_category['und'][0]['value'] != $u->position_category)
      $edit['field_uib_position_category']['und'][0]['value'] = $u->position_category;
    if ($account->field_uib_phone != $phones)
      $edit['field_uib_phone'] = $phones;
    // Some roles have no correspondence in Sebra and will be lost if we do not fix it here.
    // All roles but 'level 2' and 'level 3' are fixed.
    foreach ($account->roles as $key => $value) {
      if ($value != 'level 2' OR $value != 'level 3') {
        $u->roles[$key] = $value;
      }
    }
    if ($account->roles != $u->roles)
      $edit['roles'] = $u->roles;

    if (empty($edit)) {
      uibx_log("No user field change for $username <$account->mail>");
    }
    else {
      if (!$dry_run)
        user_save($account, $edit);
      uibx_log("Updated user fields for $username <$account->mail>");
      uibx_log('Update-'.print_r($edit,true));
    }
  }
  else {
    $account = new stdClass();
    $account->is_new = 1;
    $account->name = $u->id;
    $account->mail = $u->email;
    $account->status = 1; // ACTIVE
    $account->field_uib_user_domain['und'][0]['value'] = 'uib';
    $account->field_uib_first_name['und'][0]['value'] = $u->first_name;
    $account->field_uib_last_name['und'][0]['value'] = $u->last_name;
    $account->field_uib_sort_name['und'][0]['value'] = _uib_sebra__sort_name($u->last_name);
    $account->field_uib_position['nb'][0]['value'] = $u->position_name_no;
    $account->field_uib_position['en'][0]['value'] = $u->position_name_en;
    $account->field_uib_position_code['und'][0]['value'] = $u->position_code;
    $account->field_uib_position_category['und'][0]['value'] = $u->position_category;
    $account->field_uib_phone = $phones;
    $account->roles = $u->roles;
    if (!$dry_run)
      user_save($account);
    uibx_log("Created user $account->uid for $username <$u->email>");
  }

  // Just add uid to content_manager on areas.
  // A full run of sync_users will remove stale uids from content_manager
  if (uib_sebra__add_content_manager($u->content_manager_areas, $account->uid))
    uibx_log("Content manager - updated for user $account->uid for $username <$u->email>");
  else
    uibx_log("Content manager - no change for user $account->uid for $username <$u->email>");

  return $account;
}


function uib_sebra__area_diff($list = TRUE) {
  $sebra_areas_not_in_w3 = array();
  $sebra_areas_in_w3 = array();
  $sebra_areas_confirmed = array();
  $sebra_areas_unconfirmed = array();
  // Get all sebra areas in w3
  $query = 'SELECT entity_id, field_uib_sebra_id_value FROM {field_data_field_uib_sebra_id} WHERE deleted = :false';
  $result = db_query($query, array(':false' => 0));
  foreach ($result as $record) {
    if (!empty($record->field_uib_sebra_id_value)) {
      $sebra_areas_in_w3[$record->field_uib_sebra_id_value] = $record->entity_id;
    }
  }
  // Get all sebra areas
  $sebra_areas = uib_sebra__sws_get('omraader');
  foreach ($sebra_areas->omraade as $omr) {
    $sebra_area_code = (string)$omr->OMRAADEKODE;
    $area_info = uib_sebra__sws_get('omraader?omraadekode=' . $omr->OMRAADEKODE);
    if (!empty($area_info->STATUS)) {
      var_dump($area_info);
    }
    if (!empty($sebra_areas_in_w3[$sebra_area_code])) {
      // area is in w3
      $sebra_areas_confirmed[$sebra_area_code] = array($sebra_areas_in_w3[$sebra_area_code], $omr->OMRAADE_NAVN);
    }
    else {
      // area is not in w3
      $sebra_areas_not_in_w3[$sebra_area_code] = $omr->OMRAADE_NAVN;
    }
  }
  echo count($sebra_areas_not_in_w3), ' sebra area(s) NOT FOUND in w3', PHP_EOL;
  if ($list) {
    foreach ($sebra_areas_not_in_w3 as $ei => $ar) {
      echo $ar, ' [sebra id: ', $ei, ']', PHP_EOL;
    }
  }
  echo PHP_EOL,count($sebra_areas_confirmed),' sebra area(s) FOUND in w3',PHP_EOL;
  foreach ($sebra_areas_confirmed as $ei => $ar) {
    echo $ar[1], ' [sebra id: ', $ei, '] [entity id: ', $ar[0], ']', PHP_EOL;
  }
  foreach ($sebra_areas_in_w3 as $si => $ei) {
    if (empty($sebra_areas_confirmed[$si])) {
      $sebra_areas_unconfirmed[$si] = $ei;
    }
  }
  // leftovers
  if (count($sebra_areas_unconfirmed) > 0) {
    echo PHP_EOL, count($sebra_areas_unconfirmed), ' area(s) in w3 missing in sebra:', PHP_EOL;
    foreach ($sebra_areas_unconfirmed as $si => $ei) {
      $query = 'SELECT title FROM {node} WHERE nid = :eid';
      $result = db_query($query, array(':eid' => $ei));
      foreach ($result as $record) {
        if (!empty($record->title)) {
          $unconf_title = $record->title;
        }
      }
      echo $unconf_title, ' [sebra id: ', $si, ', entity id: ', $ei, ']', PHP_EOL;
    }
  }
}

function _uib_sebra__sort_name($last_name) {
  if (substr($last_name, 0, 2) == 'Aa') {
    $last_name = substr_replace($last_name, 'Å', 0, 2);
  }
  return $last_name;
}
