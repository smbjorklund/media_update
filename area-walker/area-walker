#!/usr/bin/env python

import uib.web
import json
from collections import Counter
import argparse

class XTopic(object):
    def __init__(self, etree):
        self.etree = etree

    def id(self):
        return self.etree.get('id')

    def state(self):
        return self.etree.get('state')

    def path(self):
        return self.etree.get('path')[1:]

    def title(self):
        return self.etree.find('title').text

    def site(self):
        e = self.etree.find('site')
        return e.get('ref') if e is not None else None

    def topic_type(self):
        t = self.etree.find('type')
        if t is None:
            return None
        return t.get('name')

    def nav_kids(self, site=None):
        if site is None:
            site = self.site()
        for f in self.etree.findall('field'):
            if f.get('name') == 'menuorder' and f.get('scope') == site:
                return json.loads(f.text)
        return []

    def area_kids(self, site=None):
        for f in self.etree.findall('xlink[@name="har_tilknyttet/tilknytning/er_tilknyttet"]'):
            yield f.get('ref')

    def exported_to(self):
        site = self.site()
        for f in self.etree.findall('xlink[@name="subordinate/hierarchical-relation/superordinate"]'):
            scope = f.get('scope')
            if scope != site:
                yield scope

class XTopic_UserAgent(uib.web.UserAgent):
    prefix = "http://www.uib.no/"

    def get(self, url):
        if not url.startswith(("http:", "https")):
            url = self.prefix + url
        return super(XTopic_UserAgent, self).get(url)

    def _xtopic(self, etree):
        if etree is None:
            return None
        t = etree.find('topic')
        if t is None:
            return None
        return XTopic(t)

    def get_xtopic(self, xid):
        return self._xtopic(self.get_xml_etree('topicmap/@@xtopic?id=' + str(xid)))

    def get_xtopic_by_path(self, path):
        return self._xtopic(self.get_xml_etree(path + '/xtopic'))

class Walker(object):
    def __init__(self, **kw):
        self.type_counter = Counter()
        self.seen_at = {}
        self.max_depth = 0
        self.count = 0
        self.__dict__.update(kw)

    def print_indent(self, depth, line):
        self.count += 1
        print '%4d %2d %s%s' % (self.count, depth, '  ' * depth, line.encode('UTF-8'))

    def xprint(self, topic, depth):
        if self.args.path_only:
            print topic.path()
            return
        line = topic.title()
        line += ' ['
        if self.args.ids:
            line += topic.id() + ', '
        t = topic.topic_type()
        if t:
            line += t
        else:
            line += 'NO_TYPE'
        tsite = topic.site()
        if tsite:
            if tsite != self.site:
                other_site = self.ua.get_xtopic(tsite)
                if other_site.id() != topic.id():
                    line += ' from'
                line += ' ' + other_site.path()
            else:
                for esite in topic.exported_to():
                    esite = self.ua.get_xtopic(esite)
                    line += ' exp:' + esite.path()
        else:
            line += ' imported'
        if topic.state() != 'published':
            line += ', ' + topic.state().upper()
        seen_at = self.seen_at.get(topic.id())
        if seen_at is not None:
            line += ', DUPLICATE #' + str(seen_at)
        line += ']'

        self.print_indent(depth, line)

    def walk(self, topic, depth=0):
        if self.args.published and topic.state() != 'published':
            return

        if depth == 0:
            self.site = topic.site()

        self.xprint(topic, depth)

        if depth > self.max_depth:
            self.max_depth = depth

        if topic.id() in self.seen_at:
            return
        self.seen_at[topic.id()] = self.count

        self.type_counter[topic.topic_type()] += 1;
        if self.args.areas:
            for k in topic.area_kids():
                t = self.ua.get_xtopic(k)
                self.walk(t, depth + 1)
            return
        for k in topic.nav_kids(self.site):
            t = self.ua.get_xtopic(k)
            if t:
                self.walk(t, depth + 1)
            elif not args.published:
                self.print_indent(depth + 1, '### %s does not exist!' % (k,))

arg_parser = argparse.ArgumentParser(description='Walk the navigation menus of an area')
arg_parser.add_argument('--ids', action='store_true', help='print the ids of the listed topics')
arg_parser.add_argument('--published', action='store_true', help='only show published stuff')
arg_parser.add_argument('--areas', action='store_true', help='walk sub areas instead of menues')
arg_parser.add_argument('--path-only', action='store_true', help='only print paths')
arg_parser.add_argument('area', nargs='+', help='area path to start traversing')

args = arg_parser.parse_args()

areas = []
ua = XTopic_UserAgent()

for area in args.area:
    t = ua.get_xtopic_by_path(area)
    if t is None:
        import sys
        sys.stderr.write('No such area: ' + repr(area) + '\n')
        sys.exit(1)
    areas.append(t)

walker = Walker(ua=ua, args=args)
for area in areas:
    walker.walk(area)

if not args.path_only:
    print
    print walker.type_counter
    print 'max depth', walker.max_depth
